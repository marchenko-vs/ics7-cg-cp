\input{preambule.tex}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Визуализация реалистичного дождя в разное время суток}
    {ИУ7-53Б}
    {В.~Марченко}
    {~А.~С.~Кострицкий}
    {}
    {}
    
\tableofcontents

{\center\chapter*{Введение}}
\addcontentsline{toc}{chapter}{Введение}

Атмосферные эффекты --- такие как дождь, туман, огонь, дым, облака, свечение звезд и снег --- важны для создания реалистичной среды в интерактивных приложениях (обучающих системах, играх, фильмах и т. п.). 
Поскольку скорость вычислений современных графических аппаратных средств увеличивается, для погружения пользователя в визуально реалистичную среду также требуется и высокая степень реализма изображения. 
Однако визуализация атмосферных осадков, особенно в реальном времени, является сложной задачей \cite[1]{Tariq2007}.

Дождь представляет собой очень сложное атмосферное физическое явление и состоит из многочисленных эффектов. 
Дождь может быть небольшим, умеренным, ситным, полосовым или грозовым. 
На улицах образуются лужи и разбрызгиваются капли. 
Можно увидеть рябь, падающие дождевые капли, стекающие с поверхностей предметов и т. д. \cite{Hao2008}

Визуальные эффекты дождя содержат сложные физические механизмы, отражающие физические, оптические и статистические характеристики капель. 
Кроме того, капли дождя претерпевают сильные искажения формы при падении, называемые колебаниями. 
Из-за колебаний отражение и преломление света через падающую каплю дождя создают сложные картины яркости в пределах одной размытой в движении полосы дождя, снятой камерой или наблюдаемой человеком. 
Яркостная картина полосы дождя обычно включает в себя крапинки, множественные размытые блики и изогнутые контуры яркости \cite{Garg2006}.

Целью курсовой работы является реализация программного обеспечения для визуализации дождя в реальном времени с возможностью изменения с помощью графического интерфейса таких характеристик, как плотность дождя, размер капель, скорость падения дождя и направление падения дождевых капель. 
Также должна быть реализована возможность изменения положения камеры и источника света по осям $X$ и $Y$ и смена дня и ночи.

Задачами данной работы являются:
\begin{enumerate}
\item[1)]
выбор способа представления объектов на сцене;
\item[2)]
выбор модели дождевых капель;
\item[3)]
анализ алгоритмов удаления невидимых линий и поверхностей и выбор наиболее подходящего;
\item[4)]
анализ алгоритмов создания реалистичного освещения, отражений и теней и выбор наиболее подходящего;
\item[5)]
анализ и выбор средств программной реализации;
\item[6)]
реализация выбранных алгоритмов для создания программы визуализации дождя в реальном времени;
\item[7)]
создание графического интерфейса для возможности изменения характеристик дождя и сцены пользователем.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Описание объектов сцены}

Сцена должна состоять из нескольких объектов.

Источник света (точечный) --- материальная точка, излучающая свет во всех направлениях, причем интенсивность света уменьшается с расстоянием. 
Положение источника света задается тремя координатами $(x, y, z)$ относительно начала координат.

Время суток. 
Оно не имеет собственной модели, однако оказывает влияние на восприятие человеком сцены. 
В программе должны быть реализованы день и ночь. 
День соответствует яркой и светлой цветовой гамме, а ночь --- темной и приглушенной.

Дождевые капли --- основной объект сцены, так как главной целью данной работы является визуализация дождя. 
Модель дождевой капли описана в аналитической части в пункте~\ref{sec:dropletmodel}.

Земля --- параллелепипед зеленого цвета внизу сцены, куда должны падать капли дождя. 

\section{Способы задания моделей}

Существует три способа задания моделей:

\begin{enumerate}
\item[1)]
каркасная модель;
\item[2)]
поверхностная модель;
\item[3)]
объемная твердотельная модель \cite{Kuritsina2011}.
\end{enumerate}

Каркасная модель представляет форму деталей в виде конечного множества линий. Для каждой линии известны координаты концевых точек и функция линии \cite{Kuritsina2011}.

Поверхностная модель представляет форму деталей с помощью ограничивающих ее поверхностей (данные о гранях, вершинах, ребрах и функции поверхностей) \cite{Kuritsina2011}.

Объемные твердотельные модели дополнительно содержат в явной форме сведения о принадлежности элементов внутреннему или внешнему по отношению к детали пространству \cite{Kuritsina2011}.

Каркасная модель для визуализации дождя в реальном времени не подходит, так как капли дождя (как и другие осадки) сложно воспринимаются человеком в таком виде, а совокупность подобных моделей превращается в неразборчивую сцену. 
Так как цель курсовой работы не предполагает взаимодействия с объектами на сцене, объемные твердотельные модели также не подходят для использования. 
По приведенным выше причинам оптимальным способом задания моделей является поверхностная.

\section{Способы задания поверхностных моделей}

Поверхностные модели могут задаваться двумя способами: параметрическим представлением и полигональной сеткой.

Параметрическое представление --- для получения поверхности необходимо вычислить функцию, которая зависит от параметра.

Полигональная сетка --- совокупность вершин, ребер и граней, которые определяют форму объекта.

В свою очередь второй способ подразделяется на три варианта реализации:

\begin{enumerate}
\item[1)]
вершинное представление --- хранятся вершины, указывающие на другие вершины, с которыми они соединены;
\item[2)]
список граней --- объект представляется как множество граней и вершин;
\item[3)]
таблица углов --- хранит вершины в предопределенной таблице.
\end{enumerate}

Наиболее важной характеристикой для выбора способа задания поверхностной модели в курсовой работе является скорость. 
Поэтому была выбрана модель, заданная полигональной сеткой, которая позволяет избежать проблем при описании сложных объектов сцены. 
Оптимальный способ, позволяющий эффективно преобразовывать модели, является способ хранения полигональной сетки при помощи списка граней.

\section{Модель дождевой капли}
\label{sec:dropletmodel}

Существует множество способов представления дождевых капель в зависимости от используемых физических свойств: геометрических, динамических и оптических. 
    
Один из способов реалистичной и эффективной визуализации осадков (не только дождя) на сценах с движущейся камерой --- наложение текстур на двойной конус. 
Данный метод предлагает более точный контроль над факторами движения и внешним видом капель.

Еше один вариант визуализации капли --- использование сферы или эллипса. 
Последний способ позволяет улучшить восприятие сцены, так как при помощи масштабирования объекта, можно воссоздать эффект воздействия гравитации на капли.

\section{Алгоритм анимации дождя}

Дождь традиционно моделируется одним из двух способов: либо как система частиц, либо как геометрия, ориентированная на камеру, с прокручивающимися текстурами \cite[2]{Tariq2007}.

Методы, использующие второй способ анимации дождя, обычно используются при моделировании в реальном времени. 
Эти методы быстрые, но результаты могут выглядеть так, как будто им не хватает глубины. 
Кроме того, используя алгоритмы такого рода сложно показать комплексную динамику, такую как штормовой ветер, или реагировать на локальное освещение, такое как уличные фонари \cite[2]{Tariq2007}.

Дождь также можно моделировать как систему частиц, но в прошлом этот подход считался медленным для приложений реального времени, особенно для сцен, изображающих сильный дождь \cite[2]{Tariq2007}.

Упрощенная анимация падения дождевых капель. 
Для создания эффекта падения дождя нужно менять координаты $y$ у всех капель через определенные равные интервалы времени.
Чтобы изменить направления падения дождя, нужна изменить координаты $x$ и $z$. 
Таким образом, создается эффект падения дождя под определенным углом к горизонту.

\section{Алгоритмы удаления невидимых линий и поверхностей}
\label{sec:z_buffer}

Сложность задачи удаления невидимых линий и поверхностей привела к появлению большого числа различных способов ее решения. 
Наилучшего решения обшей задачи удаления невидимых линий и поверхностей не существует. 
Учет эффектов прозрачности, фактуры, отражения и т. п. не входит в задачу удаления невидимых линий или поверхностей. 
Естественнее считать их частью процесса визуализации изображения. 
Однако многие из этих эффектов встроены в алгоритмы удаления невидимых поверхностей. 
Существует тесная взаимосвязь между скоростью работы алгоритма и детальностью его результата. 
Ни один из алгоритмов не может достигнуть хороших оценок для этих двух показателей одновременно. 
По мере создания все более быстрых алгоритмов можно строить все более детальные изображения \cite{Demin2005}.

Алгоритмы удаления невидимых линий или поверхностей можно классифицировать по способу выбора системы координат или пространства, в котором они работают. Выделяют три класса алгоритмов удаления невидимых линий или поверхностей:

\begin{enumerate}
\item[1)]
алгоритмы, работающие в объектном пространстве;
\item[2)]
алгоритмы, работающие в пространстве изображения;
\item[3)]
алгоритмы, формирующие список приоритетов \cite{Demin2005}.
\end{enumerate}

Алгоритмы, работающие в объектном пространстве, имеют дело с физической системой координат, в которой описаны эти объекты. 
При этом получаются весьма точные результаты, ограниченные лишь точностью вычислений. 
Полученные изображения можно свободно увеличивать во много раз. 
Алгоритмы, работающие в объектном пространстве, особенно полезны в тех приложениях, где необходима высокая точность \cite{Demin2005}.

Алгоритмы же, работающие в пространстве изображения, имеют дело с системой координат того экрана, на котором объекты визуализируются. 
При этом точность вычислений ограничена разрешающей способностью экрана. Обычно разрешение экрана бывает довольно низким. 
Результаты, полученные в пространстве изображения, а затем увеличенные во много раз, не будут соответствовать исходной сцене \cite{Demin2005}.

Алгоритмы, формирующие список приоритетов, работают попеременно в обеих упомянутых системах координат \cite{Demin2005}.

В рамках данной курсовой работы разрабатывается программа визуализации дождя в реальном времени, поэтому быстродействие алгоритмов является самым важным фактором. Исходя из этого, нужно выбирать алгоритмы удаления невидимых линий и поверхностей, которые работают в пространстве изображений.

Алгоритм Робертса характеризуется высокой точностью вычислений, но существует ограничение на выпуклость тел и он работает менее эффективно с появлением новых объектов на сцене.

Алгоритм, использующий $Z$-буфер, использует относительно много памяти (так как использует массивы) и с помощью него сложно реализовать эффекты прозрачности. 
Кроме того, недостаток состоит в трудоемкости и высокой стоимости устранения лестничного эффекта. 
Но он обладает простой реализацией, не требует временных затрат на сортировку объектов сцены и скорость работы алгоритма растет линейно при появлении новых объектов.

Алгоритм обратной трассировки лучей позволяет работать с поверхностями, заданными в математической форме, а также позволяет получить высокую реалистичность синтезируемого изображения. 
С другой стороны, алгоритм обладает низкой производительностью.

Таким образом, наилучшим алгоритмом для удаления невидимых линий и поверхностей при визуализации дождя будет алгоритм, использующий $Z$-буфер.

\section{Алгоритм построения теней}

Целью текущей куросовой работы является визуализация дождя. Таким образом, есть возможность пренебречь тенями и использовать для визуализации объектов алгоритм, выбранный в пункте~\ref{sec:z_buffer}.

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы были рассмотрены способы представления объектов и алгоритмы, необходимые для построения реалистичных изображений --- алгоритмы, удаляющие невидимые линии и поверхности и алгоритмы построения теней.

В итоге были выбраны:

\begin{enumerate}
\item[1)]
поверхностная модель (путем хранения списка граней) для представления объектов;
\item[2)]
сфера для представления дождевых капель;
\item[3)]
алгоритм, использующий $Z$-буфер для удаления невидимых линий и поверхностей.
\end{enumerate}

\chapter{Конструкторская часть}

В данной части описаны все необходимые алгоритмы и средства для визуализации дождя.

\section{Общий алгоритм визуализации сцены}

\begin{enumerate}
\item
Установить начальную скорость падения дождя.
\item
Установить начальный размер дождевых капель.
\item
Установить направление падения дождя.
\item
Установить плотность падения дождя.
\item
Установить соответствующую цветовую гамму исходя из выбранного времени суток (по умолчанию --- ночь).
\item
Установить начальное положение источника света.
\item
Установить начальное положение камеры.
\item
С учетом текущего положения камеры и источника света визуализировать падение дождя.
\end{enumerate}

\section{Графический конвейер}

Графический конвейер --- комплекс визуализации трехмерной графики, последовательность этапов, выполняющихся в фиксированном порядке. 
Каждое состояние принимает информацию из предыдущего состояния и отправляет в следующее. 
Стандартный графический конвейер обрабатывает вершины, геометрические примитивы, а также пиксели конвейерным способом.

На рисунке~\ref{img:graphics_pipeline} изображена схема графического конвейера, с помощью которого происходит преобразование локальных координат всех объектов в экранные координаты.

\includeimage{graphics_pipeline}
    {f}
    {H}
    {.2\textwidth}
    {Графический конвейер}
    
Все преобразования происходят за счет последовательного умножения следующих матриц: модельной, видовой и проекционной. 
Для составления модельной матрицы нужно умножить матрицы масштабирования,  поворота и параллельного переноса. 

Матрица масштабирования:
\begin{equation}
\begin{gathered}
S = 
	\begin{bmatrix}
		kx & 0 & 0 & 0 \\
		0 & ky & 0 & 0 \\
		0 & 0 & kz & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $kx$, $ky$, $kz$ --- коэффициенты масштабирования.

Матрица поворота вокруг оси $X$:
\begin{equation}
\begin{gathered}
R_x = 
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & cos(\alpha) & -sin(\alpha) & 0 \\
		0 & sin(\alpha) & cos(\alpha) & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $\alpha$  --- угол поворота вокруг оси $X$.

Матрица поворота вокруг оси $Y$:
\begin{equation}
\begin{gathered}
R_y = 
	\begin{bmatrix}
		cos(\beta) & 0 & sin(\beta) & 0 \\
		0 & 1 & 0 & 0 \\
		-sin(\beta) & 0 & cos(\beta) & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $\beta$  --- угол поворота вокруг оси $Y$.

Матрица поворота вокруг оси $Z$:
\begin{equation}
\begin{gathered}
R_z = 
	\begin{bmatrix}
		cos(\gamma) & -sin(\gamma) & 0 & 0 \\
		sin(\gamma) & cos(\gamma) & 0 & 0 \\
		0 & 0 & 1 & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $\gamma$  --- угол поворота вокруг оси $Z$.

<<Полную>> матрицу поворота можно получить по следующей формуле:
\begin{equation}
R = R_x \cdot R_y \cdot R_z.
\end{equation}

Матрица параллельного переноса:
\begin{equation}
\begin{gathered}
T = 
	\begin{bmatrix}
		1 & 0 & 0 & dx \\
		0 & 1 & 0 & dy \\
		0 & 0 & 1 & dz \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $dx$, $dy$, $dz$ --- расстояния, на которые перемещается объект вдоль соответствующих осей.

Таким образом, модельная матрица может быть посчитана по следующей формуле:
\begin{equation}
M = T \cdot R \cdot S,
\end{equation}
где $T$ --- матрица параллельного переноса, $R$ --- матрица поворота, $S$ --- матрица масштабирования.

Чтобы составить видовую матрицу, нужны несколько векторов. 
Вектор $From$, который описывает направление <<взгляда>> камеры, вектор $Target$, который указывает куда смотрит камера (этот вектор направлен в обратную сторону относительно вектора $From$), и вектор $Up$ --- вектор, направленный вверх. 
Вектор $Forward$ можно найти как разность векторов $From$ и $Target$. 
Вектор $Right$ можно найти как векторное произведение векторов $Up$ и $Forward$. 
Вектор $U$ можно найти как векторное произведение векторов $Forward$ и $Right$.

Видовая матрица:
\begin{equation}
\begin{gathered}
V = 
	\begin{bmatrix}
		Right_x & Right_y & Right_z & 0 \\
		U_x & U_y & U_z & 0 \\
		Forward_x & Forward_y & Forward_z & 0 \\
		From_x & From_y & From_z & 1
	\end{bmatrix}.
\end{gathered}
\end{equation}

Пусть $z_{near}$ --- положение ближней к камере плоскости, а $z_{far}$ --- дальней.

Матрица проекции:
\begin{equation}
\begin{gathered}
P = 
	\begin{bmatrix}
		\frac{fov}{aspect} & 0 & 0 & 0 \\
		0 & fov & 0 & 0 \\
		0 & 0 & -f & 0 \\
		0 & 0 & 0 & f \cdot z_{near}
	\end{bmatrix},
\end{gathered}
\end{equation}
где $fov$ --- угол обзора в радианах, $aspect$ --- отношение ширины сцены к высоте, а $f$ --- величина, которую можно посчитать по формуле:
\begin{equation}
f = \frac{-z_{far}}{(z_{far} - z_{near})}.
\end{equation}

Таким образом, полная матрица, которая описывает все преобразования, может быть посчитана по формуле:
\begin{equation}
MVP = P \cdot V \cdot M,
\end{equation}
где $P$ --- матрица проекции, $V$ --- видовая матрица, $M$ --- модельная матрица.

Чтобы получить преобразованные координаты, нужно исходный вектор $V$ умножить на матрицу $MVP$:
\begin{equation}
V' = MVP \cdot V.
\end{equation}
    
\section{Описание геометрии}
\label{sec:geometry}

Для выполнения курсовой работы был выбран формат файлов \textbf{OBJ} --- это простой формат данных, который содержит только трехмерную геометрию, а именно: позицию каждой вершины, связь координат текстуры с вершиной, нормаль для каждой вершины, а также параметры, которые создают полигоны. 
В качестве полигонов будут использоваться треугольники.

Для считывания объектов из \textbf{OBJ} файла используются строки, начинающиеся на \textbf{v} и \textbf{f}. 
Числа, расположенные после \textbf{v}, являются координатами текущей вершины, а числа, расположенные после \textbf{f}, показывают, из каких вершин состоит текущая грань.

\section{Описание алгоритмов}

\subsection{Алгоритм, использующий $Z$-буфер}

Формальное описание алгоритма, использующего $Z$-буфер.

\begin{enumerate}
\item
Заполнить буфер кадра фоновым значением интенсивности или цвета.
\item
Заполнить $Z$-буфер минимальным значением $z$.
\item
Преобразовать каждый треугольник в растровую форму.
\item
Для каждого пикселя $(x, y)$ в треугольнике вычислить его глубину $z(x, y)$.
\item
Сравнить глубину $z(x, y)$ со значением $z_{buffer}(x, y)$, хранящимся в $Z$-буфере в этой же позиции. 
Если $z(x, y) > z_{buffer}(x, y)$, то записать атрибут этого треугольника в буфер кадра и заменить $z_{buffer}(x, y)$ на $z(x, y)$. 
В противном случае никаких действий не производить \cite{Demin2005}.
\end{enumerate}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы был описан общий алгоритм визуализации сцены, графический конвейер, описана геометрия и формально описан алгоритм, использующий $Z$-буфер.

\chapter{Технологическая часть}

В текущем разделе приведены средства реализации необходимых структур данных и алгоритмов, а также листинги кода.

\section{Требования к программному обеспечению}

Программа должна предоставлять следующие функции.

\begin{enumerate}
\item
Смена времени суток --- дня и ночи.
\item
Поворот камеры вдоль осей $X$ и $Y$.
\item
Изменение скорости падения дождя.
\item
Изменение размера капель дождя.
\item
Изменение плотности падения дождя.
\item
Изменение направления падения дождя.
\item
Изменение положения источника света вдоль осей $X$ и $Y$.
\end{enumerate}

\section{Средства реализации}

Для реализации программного обеспечения был выбран язык \textbf{C++} и фреймворк \textbf{Qt} для разработки кроссплатформенного программного обеспечения на языке программирования \textbf{C++} ввиду следующих причин:

\begin{enumerate}
\item[1)]
язык \textbf{C++} является объектно-ориентированным, что позволит ускорить и упростить разработку программного обеспечения с помощью использования классов;
\item[2)]
существует возможность создания производных классов на основе родительских (наследование);
\item[3)]
в библиотеке стандартных шаблонов имеется контейнер \textbf{std::vector}, который можно использовать для хранения вершин и граней объектов;
\item[4)]
фреймворк \textbf{Qt} дает возможность создавать различные виджеты для реализации графического пользовательского интерфейса;
\item[5)]
фреймворк предоставляет классы \textbf{QGraphicsView} и \textbf{QImage} для визуализации сцены;
\item[6)]
у объектов класса \textbf{QImage} есть метод \textbf{fill()}, с помощью которого можно менять цвет заднего фона для создания эффекта смены времени суток;
\item[7)]
фреймворк предоставляет доступ к классу \textbf{QTimer}, который можно использовать для изменения позиции капли дождя через определенные интервалы времени (анимация дождя).
\end{enumerate}

Таким образом, с помощью языка \textbf{C++} и фреймворка \textbf{Qt} можно реализовать программное обеспечение, которое соответствует перечисленным выше требованиям.

Для создания моделей было выбрано программное обеспечение для создания трехмерной компьютерной графики под названием \textbf{Blender}, которое позволяет создавать трехмерные модели, состоящие из треугольных полигонов, что подходит под требования, описанные в пункте~\ref{sec:geometry}.

\section{Реализация структур данных}

\subsection{Вершины}

В листинге~\ref{lst:vertex.cpp} показана реализация класса, который отвечает за хранение координат одной вершины объекта.

\includelistingpretty
{vertex.cpp}{c++}{Класс вершин}

\subsection{Грани}

В листинге~\ref{lst:face.cpp} показана реализация класса, который отвечает за хранение одной грани объекта. 
В массиве \textbf{vertices} хранится три порядковых номера вершин, которые образуют один полигон (треугольник).

\includelistingpretty
{face.cpp}{c++}{Класс граней}

\subsection{Векторы}

В листинге~\ref{lst:vector4d.cpp} показана реализация класса, который представляет собой четырехмерный вектор. 
Класс предоставляет несколько методов для совершения математических операций над векторами. 
Четырехмерные векторы нужны для аффинных преобразований и графического конвейера.

\includelistingpretty
{vector4d.cpp}{c++}{Класс векторов}

\subsection{Матрицы}

В листинге~\ref{lst:matrix.cpp} показана реализация класса, который представляет собой квадратную матрицу размером $4 \times 4$. 
Класс предоставляет операцию умножения двух таких матриц и операцию умножения матрицы на четырехмерный вектор. 
Кроме того, у класса есть несколько статических методов, которые возвращают тот или иной тип матрицы, который используется в графическом контейнере. 
Четырехмерные матрицы нужны для аффинных преобразований и графического конвейера.

\includelistingpretty
{matrix.cpp}{c++}{Класс матриц}

\subsection{Объекты}

В листинге~\ref{lst:object.cpp} показана реализация базового класса, который представляет собой объект сцены. 
Классы других объектов можно создавать на основе класса \textbf{Object}. 
Класс хранит текущее смещение объекта, коэффициенты масштабирования и углы поворотов вокруг трех осей. 
Кроме того, для \textbf{Object} реализованы методы для преобразований объекта и визуализации (метод \textbf{draw}).

\includelistingpretty
{object.cpp}{c++}{Класс объектов}

\section{Реализация алгоритмов}

\subsection{Алгоритм, использующий $Z$-буфер}

В листинге~\ref{lst:draw_polygon.cpp} показана реализация метода \textbf{draw\_polygon} для класса \textbf{Object}, который представляет собой алгоритм, использующий $Z$-буфер. 
Метод в качестве параметров принимает три вершины полигона, массив, представляющий собой $Z$-буфер, указатель на сцену и цвет полигона. 
Чтобы визуализировать весь объект, нужно вызвать метод \textbf{draw\_polygon} для всех полигонов.

\includelistingpretty
{draw_polygon.cpp}{c++}{Алгоритм, использующий $Z$-буфер}

\subsection{Алгоритм генерации дождевых капель}

В листинге~\ref{lst:generate_rain.cpp} показана реализация метода \textbf{generateRain}, который отвечает за первоначальное размещение на сцене всех капель дождя.

\includelistingpretty
{generate_rain.cpp}{c++}{Алгоритм генерации дождевых капель}

\section*{Вывод из технологической части}

В данном разделе был написан исходный код необходимых структур данных и алгоритмов визуализации сцены и анимации объектов. 

\chapter{Исследовательская часть}

\section{Примеры работы программы}

На рисунках~\ref{img:work_example_01}--\ref{img:work_example_04} показаны примеры работы программы при различных параметрах дождя и сцены.

\includeimage{work_example_01}
    {f}
    {H}
    {0.9\textwidth}
    {Дождь в ночное время суток}
    
\includeimage{work_example_02}
    {f}
    {H}
    {0.9\textwidth}
    {Дождь в дневное время суток}
    
\includeimage{work_example_03}
    {f}
    {H}
    {0.9\textwidth}
    {Увеличенный размер капель дождя}
    
\includeimage{work_example_04}
    {f}
    {H}
    {0.9\textwidth}
    {Измененное положение камеры и источника света}

\section*{Вывод из исследовательской части}

В данном разделе представлены примеры работы программы при различных параметрах дождя и сцены. 

{\center\chapter*{Заключение}}
\addcontentsline{toc}{chapter}{Заключение}

В результате выполнения курсовой работы было реализовано программное обеспечение для визуализации дождя в реальном времени с возможностью изменения с помощью графического интерфейса таких характеристик, как размер капель, скорость падения дождя и направление падения дождевых капель. 
Также была реализована возможность изменения положения камеры и источника света вдоль осей $X$ и $Y$ и смена дня и ночи. 
Не была реализована возможность изменения плотности дождя.

Были выполнены следующие задачи:
\begin{enumerate}
\item[1)]
выбран способ представления объектов на сцене;
\item[2)]
выбрана модель дождевых капель;
\item[3)]
проанализированы алгоритмы удаления невидимых линий и поверхностей и выбран наиболее подходящий;
\item[4)]
проанализированы алгоритмы создания реалистичного освещения, отражений и теней и выбран наиболее подходящий;
\item[5)]
проанализированы и выбраны средства программной реализации;
\item[6)]
реализованы выбранные алгоритмы для создания программы визуализации дождя в реальном времени;
\item[7)]
создан графический интерфейс для возможности изменения характеристик дождя и сцены пользователем.
\end{enumerate}

{\center\printbibliography[title=Список использованных источников]}
\addcontentsline{toc}{chapter}{Список использованных источников}

\end{document}
