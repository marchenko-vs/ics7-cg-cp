\input{preambule.tex}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Визуализация реалистичного дождя в разное время суток}
    {ИУ7-53Б}
    {В.~Марченко}
    {~А.~С.~Кострицкий}
    {}
    {}
    
\tableofcontents

{\center\chapter*{Введение}}
\addcontentsline{toc}{chapter}{Введение}

Атмосферные эффекты --- такие как дождь, туман, огонь, дым, облака, свечение звезд и снег --- важны для создания реалистичной среды в интерактивных приложениях (обучающих системах, играх, фильмах и т. п.). 
Поскольку скорость вычислений современных графических аппаратных средств увеличивается, для погружения пользователя в визуально реалистичную среду также требуется и высокая степень реализма изображения. 
Однако визуализация атмосферных осадков, особенно в реальном времени, является сложной задачей [7].

Дождь представляет собой очень сложное атмосферное физическое явление и состоит из многочисленных эффектов. 
Дождь может быть небольшим, умеренным, ситным, полосовым или грозовым. 
На улицах образуются лужи и разбрызгиваются капли. 
Можно увидеть рябь, падающие дождевые капли, стекающие с поверхностей предметов и т. д. [4]

Визуальные эффекты дождя содержат сложные физические механизмы, отражающие физические, оптические и статистические характеристики капель. 
Кроме того, капли дождя претерпевают сильные искажения формы при падении, называемые колебаниями. 
Из-за колебаний отражение и преломление света через падающую каплю дождя создают сложные картины яркости в пределах одной размытой в движении полосы дождя, снятой камерой или наблюдаемой человеком. 
Яркостная картина полосы дождя обычно включает в себя крапинки, множественные размытые блики и изогнутые контуры яркости [6].

Целью курсовой работы является реализация программного обеспечения для визуализации дождя в реальном времени с возможностью изменения с помощью графического интерфейса таких характеристик, как плотность дождя, размер капель, скорость падения дождя и направление падения дождевых капель.

Задачами данной работы являются:

\begin{enumerate}
\item[1)]
выбор способа представления объектов на сцене;
\item[2)]
выбор модели дождевых капель;
\item[3)]
анализ алгоритмов удаления невидимых линий и поверхностей и выбор наиболее подходящего;
\item[4)]
анализ алгоритмов создания реалистичного освещения, отражений и теней и выбор наиболее подходящего;
\item[5)]
анализ и выбор средств программной реализации;
\item[6)]
реализация выбранных алгоритмов для создания программы визуализации дождя в реальном времени;
\item[7)]
создание графического интерфейса для возможности изменения характеристик дождя пользователем.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Описание объектов сцены}

Сцена должна состоять из нескольких объектов.

Источник света (точечный) --- материальная точка, излучающая свет во всех направлениях, причем интенсивность света уменьшается с расстоянием. 
Положение источника света задается тремя координатами $(x, y, z)$ относительно начала координат.

Время суток. 
Оно не имеет собственной модели, однако оказывает влияние на восприятие человеком сцены. 
В программе должны быть реализованы день и ночь. 
День соответствует яркой и светлой цветовой гамме, а ночь --- темной и приглушенной.

Дождевые капли --- основной объект сцены, так как главной целью данной работы является визуализация дождя. 
Модель дождевой капли описана в аналитической части в пункте~\ref{sec:dropletmodel}.

Земля --- параллелепипед зеленого цвета внизу сцены, куда должны падать капли дождя. 

\section{Способы задания моделей}

Существует три способа задания моделей:

\begin{enumerate}
\item[1)]
каркасная модель;
\item[2)]
поверхностная модель;
\item[3)]
объемная твердотельная модель [1].
\end{enumerate}

Каркасная модель представляет форму деталей в виде конечного множества линий. Для каждой линии известны координаты концевых точек и функция линии [1].

Поверхностная модель представляет форму деталей с помощью ограничивающих ее поверхностей (данные о гранях, вершинах, ребрах и функции поверхностей) [1].

Объемные твердотельные модели дополнительно содержат в явной форме сведения о принадлежности элементов внутреннему или внешнему по отношению к детали пространству [1].

Каркасная модель для визуализации дождя в реальном времени не подходит, так как капли дождя (как и другие осадки) сложно воспринимаются человеком в таком виде, а совокупность подобных моделей превращается в неразборчивую сцену. 
Так как цель курсовой работы не предполагает взаимодействия с объектами на сцене, объемные твердотельные модели также не подходят для использования. 
По приведенным выше причинам оптимальным способом задания моделей является поверхностная.

\section{Способы задания поверхностных моделей}

Поверхностные модели могут задаваться двумя способами: параметрическим представлением и полигональной сеткой.

Параметрическое представление --- для получения поверхности необходимо вычислить функцию, которая зависит от параметра.

Полигональная сетка --- совокупность вершин, ребер и граней, которые определяют форму объекта.

В свою очередь второй способ подразделяется на три варианта реализации:

\begin{enumerate}
\item[1)]
вершинное представление --- хранятся вершины, указывающие на другие вершины, с которыми они соединены;
\item[2)]
список граней --- объект представляется как множество граней и вершин;
\item[3)]
таблица углов --- хранит вершины в предопределенной таблице.
\end{enumerate}

Наиболее важной характеристикой для выбора способа задания поверхностной модели в курсовой работе является скорость. 
Поэтому была выбрана модель, заданная полигональной сеткой, которая позволяет избежать проблем при описании сложных объектов сцены. 
Оптимальный способ, позволяющий эффективно преобразовывать модели, является способ хранения полигональной сетки при помощи списка граней.

\section{Модель дождевой капли}
\label{sec:dropletmodel}

Существует множество способов представления дождевых капель в зависимости от используемых физических свойств: геометрических, динамических и оптических. 
    
Один из способов реалистичной и эффективной визуализации осадков (не только дождя) на сценах с движущейся камерой --- наложение текстур на двойной конус. 
Данный метод предлагает более точный контроль над факторами движения и внешним видом капель.

Еше один вариант визуализации капли --- использование сферы или эллипса. 
Последний способ позволяет улучшить восприятие сцены, так как при помощи масштабирования объекта, можно воссоздать эффект воздействия гравитации на капли.

\section{Алгоритм анимации дождя}

Дождь традиционно моделируется одним из двух способов: либо как система частиц, либо как геометрия, ориентированная на камеру, с прокручивающимися текстурами [7].

Методы, использующие второй способ анимации дождя, обычно используются при моделировании в реальном времени. 
Эти методы быстрые, но результаты могут выглядеть так, как будто им не хватает глубины. 
Кроме того, используя алгоритмы такого рода сложно показать комплексную динамику, такую как штормовой ветер, или реагировать на локальное освещение, такое как уличные фонари [7].

Дождь также можно моделировать как систему частиц, но в прошлом этот подход считался медленным для приложений реального времени, особенно для сцен, изображающих сильный дождь [7].

Традиционно анимация частиц либо выполняется на центральном процессоре, либо должна быть сопоставлена с графическим процессором [7].

Упрощенная анимация падения дождевых капель. 
Для создания эффекта падения дождя нужно менять координаты $y$ у всех капель через определенные равные интервалы времени.
Чтобы изменить направления падения дождя, нужна изменить координаты $x$ и $z$. 
Таким образом, создается эффект падения дождя под определенным углом к горизонту.

\section{Алгоритмы удаления невидимых линий и поверхностей}
\label{sec:z_buffer}

Сложность задачи удаления невидимых линий и поверхностей привела к появлению большого числа различных способов ее решения. 
Наилучшего решения обшей задачи удаления невидимых линий и поверхностей не существует. 
Учет эффектов прозрачности, фактуры, отражения и т. п. не входит в задачу удаления невидимых линий или поверхностей. 
Естественнее считать их частью процесса визуализации изображения. 
Однако многие из этих эффектов встроены в алгоритмы удаления невидимых поверхностей. 
Существует тесная взаимосвязь между скоростью работы алгоритма и детальностью его результата. 
Ни один из алгоритмов не может достигнуть хороших оценок для этих двух показателей одновременно. 
По мере создания все более быстрых алгоритмов можно строить все более детальные изображения [2].

Алгоритмы удаления невидимых линий или поверхностей можно классифицировать по способу выбора системы координат или пространства, в котором они работают. Выделяют три класса алгоритмов удаления невидимых линий или поверхностей:

\begin{enumerate}
\item[1)]
алгоритмы, работающие в объектном пространстве;
\item[2)]
алгоритмы, работающие в пространстве изображения;
\item[3)]
алгоритмы, формирующие список приоритетов [2].
\end{enumerate}

Алгоритмы, работающие в объектном пространстве, имеют дело с физической системой координат, в которой описаны эти объекты. 
При этом получаются весьма точные результаты, ограниченные лишь точностью вычислений. 
Полученные изображения можно свободно увеличивать во много раз. 
Алгоритмы, работающие в объектном пространстве, особенно полезны в тех приложениях, где необходима высокая точность [2].

Алгоритмы же, работающие в пространстве изображения, имеют дело с системой координат того экрана, на котором объекты визуализируются. 
При этом точность вычислений ограничена разрешающей способностью экрана. Обычно разрешение экрана бывает довольно низким. 
Результаты, полученные в пространстве изображения, а затем увеличенные во много раз, не будут соответствовать исходной сцене [2].

Алгоритмы, формирующие список приоритетов, работают попеременно в обеих упомянутых системах координат [2].

В рамках данной курсовой работы разрабатывается программа визуализации дождя в реальном времени, поэтому быстродействие алгоритмов является самым важным фактором. Исходя из этого, нужно выбирать алгоритмы удаления невидимых линий и поверхностей, которые работают в пространстве изображений.

Алгоритм Робертса характеризуется высокой точностью вычислений, но существует ограничение на выпуклость тел и он работает менее эффективно с появлением новых объектов на сцене.

Алгоритм, использующий $Z$-буфер, использует относительно много памяти (так как использует массивы) и с помощью него сложно реализовать эффекты прозрачности. 
Кроме того, недостаток состоит в трудоемкости и высокой стоимости устранения лестничного эффекта. 
Но он обладает простой реализацией, не требует временных затрат на сортировку объектов сцены и скорость работы алгоритма растет линейно при появлении новых объектов.

Алгоритм обратной трассировки лучей позволяет работать с поверхностями, заданными в математической форме, а также позволяет получить высокую реалистичность синтезируемого изображения. 
С другой стороны, алгоритм обладает низкой производительностью.

Таким образом, наилучшим алгоритмом для удаления невидимых линий и поверхностей при визуализации дождя будет алгоритм, использующий $Z$-буфер.

\section{Алгоритм построения теней}

Целью текущей куросовой работы является визуализация дождя. Таким образом, есть возможность пренебречь тенями и использовать для визуализации объектов алгоритм, выбранный в пункте~\ref{sec:z_buffer}.

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы были рассмотрены способы представления объектов и алгоритмы, необходимые для построения реалистичных изображений --- алгоритмы, удаляющие невидимые линии и поверхности и алгоритмы построения теней.

В итоге были выбраны:

\begin{enumerate}
\item[1)]
поверхностная модель (путем хранения списка граней) для представления объектов;
\item[2)]
сфера для представления дождевых капель;
\item[3)]
алгоритм, использующий $Z$-буфер для удаления невидимых линий и поверхностей.
\end{enumerate}

\chapter{Конструкторская часть}

В данной части описаны все необходимые алгоритмы и средства для визуализации дождя.

\section{Общий алгоритм визуализации сцены}

\begin{enumerate}
\item
Установить начальную скорость падения дождя.
\item
Установить начальные размеры дождевых капель.
\item
Установить направление падения дождя.
%\item
%Установить плотность падения дождя.
\item
Установить соответствующую цветовую гамму исходя из выбранного времени суток (по умолчанию --- день).
\item
Установить начальное положение источника света.
\item
Установить начальное положение камеры.
\item
С учетом текущего положения камеры и источника света визуализировать падение дождя.
\end{enumerate}

\section{Графический конвейер}

Графический конвейер --- комплекс визуализации трехмерной графики, последовательность этапов, выполняющихся в фиксированном порядке. 
Каждое состояние принимает информацию из предыдущего состояния и отправляет в следующее. 
Стандартный графический конвейер обрабатывает вершины, геометрические примитивы, а также пиксели конвейерным способом.

На рисунке~\ref{img:graphics_pipeline} изображена схема графического конвейера, с помощью которого происходит визуализация всех объектов сцены в программе.

\includeimage{graphics_pipeline}
    {f}
    {H}
    {.2\textwidth}
    {Графический конвейер}
    
Все преобразования достигаются за счет использования следующих матриц: .
    
\section{Описание геометрии}

Для выполнения курсовой работы был выбран формат файлов \textbf{OBJ} --- это простой формат данных, который содержит только трехмерную геометрию, а именно: позицию каждой вершины, связь координат текстуры с вершиной, нормаль для каждой вершины, а также параметры, которые создают полигоны. 
В качестве полигонов будут использоваться треугольники.

Для считывания объектов из \textbf{OBJ} файла используются строки, начинающиеся на \textbf{v} и \textbf{f}. 
Числа, расположенные после \textbf{v}, являются координатами текущей вершины, а числа, расположенные после \textbf{f}, показывают, из каких вершин состоит текущая грань.

\section{Описание алгоритмов}

\subsection{Алгоритм, использующий $Z$-буфер}

Формальное описание алгоритма, использующего $Z$-буфер.

\begin{enumerate}
\item
Заполнить буфер кадра фоновым значением интенсивности или цвета.
\item
Заполнить $Z$-буфер минимальным значением $z$.
\item
Преобразовать каждый треугольник в растровую форму.
\item
Для каждого пикселя $(x, y)$ в треугольнике вычислить его глубину $z(x, y)$.
\item
Сравнить глубину $z(x, y)$ со значением $z_{buffer}(x, y)$, хранящимся в $Z$-буфере в этой же позиции. 
Если $z(x, y) > z_{buffer}(x, y)$, то записать атрибут этого треугольника в буфер кадра и заменить $z_{buffer}(x, y)$ на $z(x, y)$. 
В противном случае никаких действий не производить [2].
\end{enumerate}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы был описан общий алгоритм визуализации сцены, графический конвейер и формально описан алгоритм, использующий $Z$-буфер.

\chapter{Технологическая часть}

В текущем разделе приведены средства реализации необходимых структур данных и алгоритмов, а также листинги кода.

\section{Требования к программному обеспечению}

Программа должна предоставлять следующие функции.

\begin{enumerate}
\item
Смена времени суток --- дня и ночи.
\item
Поворот камеры вдоль осей $x$ и $y$.
\item
Изменение скорости падения дождя.
\item
Изменение размеров капель дождя.
%\item
%Изменение плотности падения дождя.
\item
Изменение направления падения дождя.
\item
Изменение положения источника света вдоль осей $x$ и $y$.
\end{enumerate}

\section{Средства реализации}

Для реализации программного обеспечения был выбран язык \textbf{C++} и фреймворк \textbf{Qt} для разработки кроссплатформенного программного обеспечения на языке программирования \textbf{C++} ввиду следующих причин:

\begin{enumerate}
\item[1)]
язык \textbf{C++} является объектно-ориентированным, что позволит ускорить и упростить разработку программного обеспечения с помощью использования классов;
\item[2)]
существует возможность создания производных классов на основе родительских (наследование);
\item[3)]
в библиотеке стандартных шаблонов имеется контейнер \textbf{std::vector}, который можно использовать для хранения вершин и граней объектов;
\item[4)]
фреймворк \textbf{Qt} дает возможность создавать различные виджеты для реализации графического пользовательского интерфейса;
\item[5)]
фреймворк предоставляет классы \textbf{QGraphicsView} и \textbf{QImage} для визуализации сцены;
\item[6)]
у объектов класса \textbf{QImage} есть метод \textbf{fill()}, с помощью которого можно менять цвет заднего фона для создания эффекта смены времени суток;
\item[7)]
фреймворк предоставляет доступ к классу \textbf{QTimer}, который можно использовать для изменения позиции капли дождя с определенным интервалом времени (анимация дождя).
\end{enumerate}

Таким образом, с помощью языка \textbf{C++} и фреймворка \textbf{Qt} можно реализовать программное обеспечение, которое соответствует перечисленным выше требованиям.

\section{Реализация структур данных}

\subsection{Вершины}

В листинге~\ref{lst:vertex.cpp} показана реализация класса, который отвечает за хранение координат одной вершины объекта.

\includelistingpretty
{vertex.cpp}{c++}{Класс вершин объекта}

\subsection{Грани}

В листинге~\ref{lst:face.cpp} показана реализация структуры, которая отвечает за хранение одной грани объекта. 
В массиве \textbf{vertices} хранится три порядковых номера вершин, которые образуют одну грань (треуголник).

\includelistingpretty
{face.cpp}{c++}{Структура граней объекта}

\subsection{Векторы}

В листинге~\ref{lst:vector4d.cpp} показана реализация класса, который представляет собой четырехмерный вектор. 
Класс предоставляет несколько методов для совершения математических операций над векторами. 
Четырехмерные векторы нужны для аффинных преобразований и графического конвейера.

\includelistingpretty
{vector4d.cpp}{c++}{Класс векторов}

\subsection{Матрицы}

В листинге~\ref{lst:matrix.cpp} показана реализация класса, который представляет собой квадратную матрицу размером $4 \times 4$. 
Класс предоставляет операцию умножения двух таких матриц и операцию умножения матрицы на четырехмерный вектор. 
Кроме того, у класса есть несколько статических методов, которые возвращают тот или иной тип матрицы, который используется в графическом контейнере. 
Четырехмерные матрицы нужны для аффинных преобразований и графического конвейера.

\includelistingpretty
{matrix.cpp}{c++}{Класс матриц}

\section{Реализация алгоритмов}

\subsection{Алгоритм, использующий $Z$-буфер}

\section*{Вывод из технологической части}

В данном разделе был написан исходный код необходимых структур данных и алгоритмов визуализации сцены и анимации. 

\chapter{Исследовательская часть}

\section*{Вывод из исследовательской части}

{\center\chapter*{Заключение}}
\addcontentsline{toc}{chapter}{Заключение}

{\center\chapter*{Список использованных источников}}
\addcontentsline{toc}{chapter}{Список использованных источников}

\begin{enumerate}
\item
Геометрическое моделирование [электронный ресурс]. – URL: https://cyberpedia.su/17x1c0ef.html (дата обращения: 14.07.2022).
\item
Демин, А. Ю., Кудинов, А. В. Компьютерная графика [электронный ресурс] // Томский политехнический университет. 2005. – URL: http://compgraph.tpu.ru/ (дата обращения 05.07.2022).
\item
Мухин, О. И. Компьютерная графика [электронный ресурс]. – URL: http://stratum.ac.ru/education/textbooks/kgrafic/contents.html (дата обращения 12.07.2022).
\item
Hao, P. Algorithms for atmospheric special effects // Kanwal Rekhi School of Information Technology Indian Institute of Technology, Bombay Mumbai. 2008.
\item
Tatarchuk, N. Artist-directable real-time rain rendering in city environments // Vienna, Austria, 2006.
\item
Garg, K., Nayar, S. Photorealistic rendering of rain streaks // Columbia University.
\item
Tariq, S. Rain // NVIDIA corporation. 2007.
\item
Yuen, C. Realistic physically-based rain simulation // University of Pennsylvania. 2010.
\item
Wang, N., Wade, B. Rendering falling rain and snow.
\end{enumerate}

\end{document}
