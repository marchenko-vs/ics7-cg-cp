\input{preambule.tex}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Визуализация реалистичного дождя в разное время суток}
    {ИУ7-53Б}
    {В.~Марченко}
    {~А.~С.~Кострицкий}
    {}
    {}
    
\setcounter{page}{3}
    
\maketableofcontents

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Атмосферные эффекты --- такие как дождь, туман, огонь, дым, облака, свечение звезд и снег --- важны для создания реалистичной среды в интерактивных приложениях (обучающих системах, играх, фильмах и т.~п.). 
Поскольку скорость вычислений современных графических аппаратных средств увеличивается, для погружения пользователя в визуально реалистичную среду также требуется и высокая степень реализма изображения. 
Однако визуализация атмосферных осадков, особенно в реальном времени, является сложной задачей \cite[1]{Tariq2007}.

Дождь представляет собой очень сложное атмосферное физическое явление и состоит из многочисленных эффектов. 
Дождь может быть небольшим, умеренным, ситным, полосовым или грозовым. 
На улицах образуются лужи и разбрызгиваются капли. 
Можно увидеть рябь, падающие дождевые капли, стекающие с поверхностей предметов и т.~д. \cite{Hao2008}

Визуальные эффекты дождя содержат сложные физические механизмы, отражающие физические, оптические и статистические характеристики капель. 
Кроме того, капли дождя претерпевают сильные искажения формы при падении, называемые колебаниями. 
Из-за колебаний отражение и преломление света через падающую каплю дождя создают сложные картины яркости в пределах одной размытой в движении полосы дождя, снятой камерой или наблюдаемой человеком. 
Яркостная картина полосы дождя обычно включает в себя крапинки, множественные размытые блики и изогнутые контуры яркости \cite{Garg2006}.

Целью курсовой работы является реализация программного обеспечения для визуализации дождя в реальном времени с возможностью изменения с помощью графического интерфейса таких характеристик, как плотность дождя, размер капель, скорость падения дождя и направление падения дождевых капель. 
Также должна быть реализована возможность изменения положения источника света вдоль осей $Ox$ и $Oy$, поворот камеры вокруг осей $Ox$ и $Oy$, а также смена дня и ночи.

Задачами данной работы являются:
\begin{enumerate}
\item[1)]
выбор способа представления объектов на сцене;
\item[2)]
выбор модели дождевых капель;
\item[3)]
анализ алгоритмов удаления невидимых линий и поверхностей и выбор наиболее подходящего;
\item[4)]
анализ алгоритмов создания реалистичного освещения, отражений и теней и выбор наиболее подходящего;
\item[5)]
анализ и выбор средств программной реализации;
\item[6)]
реализация выбранных алгоритмов для создания программы визуализации дождя в реальном времени;
\item[7)]
создание графического интерфейса для возможности изменения характеристик дождя и сцены пользователем.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Описание объектов сцены}

Сцена должна состоять из нескольких объектов.

Источник света (точечный) --- материальная точка, излучающая свет во всех направлениях, причем интенсивность света уменьшается с расстоянием. 
Положение источника света задается тремя координатами $(x,~y,~z)$ относительно начала координат.

Время суток. 
Оно не имеет собственной модели, однако оказывает влияние на восприятие человеком сцены. 
В программе должны быть реализованы день и ночь. 
День соответствует яркой и светлой цветовой гамме, а ночь --- темной и приглушенной.

Дождевые капли --- основной объект сцены, так как главной целью данной работы является визуализация дождя. 
Модель дождевой капли описана в аналитической части в пункте~\ref{sec:dropletmodel}.

Земля --- параллелепипед зеленого цвета внизу сцены, куда должны падать капли дождя. 

\section{Способы задания моделей}

Существует три способа задания моделей:

\begin{enumerate}
\item[1)]
каркасная модель;
\item[2)]
поверхностная модель;
\item[3)]
объемная твердотельная модель \cite{Kuritsina2011}.
\end{enumerate}

Каркасная модель представляет форму деталей в виде конечного множества линий. Для каждой линии известны координаты концевых точек и функция линии \cite{Kuritsina2011}.

Поверхностная модель представляет форму деталей с помощью ограничивающих ее поверхностей (данные о гранях, вершинах, ребрах и функции поверхностей) \cite{Kuritsina2011}.

Объемные твердотельные модели дополнительно содержат в явной форме сведения о принадлежности элементов внутреннему или внешнему по отношению к детали пространству \cite{Kuritsina2011}.

Каркасная модель для визуализации дождя в реальном времени не подходит, так как капли дождя (как и другие осадки) сложно воспринимаются человеком в таком виде, а совокупность подобных моделей превращается в неразборчивую сцену. 
Так как цель курсовой работы не предполагает взаимодействия с объектами на сцене, объемные твердотельные модели также не подходят для использования. 
По приведенным выше причинам оптимальным способом задания моделей является поверхностная.

\section{Способы задания поверхностных моделей}

Поверхностные модели могут задаваться двумя способами: параметрическим представлением и полигональной сеткой \cite{Kuritsina2011}.

Параметрическое представление --- для получения поверхности необходимо вычислить функцию, которая зависит от параметра \cite{Kuritsina2011}.

Полигональная сетка --- совокупность вершин, ребер и граней, которые определяют форму объекта \cite{Kuritsina2011}.

В свою очередь второй способ подразделяется на три варианта реализации:

\begin{enumerate}
\item[1)]
вершинное представление --- хранятся вершины, указывающие на другие вершины, с которыми они соединены;
\item[2)]
список граней --- объект представляется как множество граней и вершин;
\item[3)]
таблица углов --- хранит вершины в предопределенной таблице \cite{Kuritsina2011}.
\end{enumerate}

Наиболее важной характеристикой для выбора способа задания поверхностной модели в курсовой работе является скорость. 
Поэтому была выбрана модель, заданная полигональной сеткой, которая позволяет избежать проблем при описании сложных объектов сцены. 
Оптимальным способом, позволяющим эффективно преобразовывать модели, является способ хранения полигональной сетки при помощи списка граней.

\section{Модель дождевой капли}
\label{sec:dropletmodel}

Существует множество способов представления дождевых капель в зависимости от используемых физических свойств: геометрических, динамических и оптических \cite{Wang}. 
    
Один из способов реалистичной и эффективной визуализации осадков (не только дождя) на сценах с движущейся камерой --- наложение текстур на двойной конус. 
Данный метод предлагает более точный контроль над факторами движения и внешним видом капель \cite{Wang}.

Еше один вариант визуализации капли --- использование сферы или эллипса. 
Последний способ позволяет улучшить восприятие сцены, так как при помощи масштабирования объекта, можно воссоздать эффект воздействия гравитации на капли.

В данной работе в качестве модели дождевой капли будет использоваться двойной конус голубого цвета.

\section{Алгоритм анимации дождя}

Дождь традиционно моделируется одним из двух способов: либо как система частиц, либо как геометрия, ориентированная на камеру, с прокручивающимися текстурами \cite[2]{Tariq2007}.

Методы, использующие второй способ анимации дождя, обычно используются при моделировании в реальном времени. 
Эти методы быстрые, но результаты могут выглядеть так, как будто им не хватает глубины. 
Кроме того, используя алгоритмы такого рода сложно показать комплексную динамику, такую как штормовой ветер, или реагировать на локальное освещение, такое как уличные фонари \cite[2]{Tariq2007}.

Дождь также можно моделировать как систему частиц, но в прошлом этот подход считался медленным для приложений реального времени, особенно для сцен, изображающих сильный дождь \cite[2]{Tariq2007}.

Упрощенная анимация падения дождевых капель. 
Для создания эффекта падения дождя нужно менять координаты $y$ у всех капель через определенные равные интервалы времени.
Чтобы изменить направления падения дождя, нужно изменить координаты $x$ и $z$. 
Таким образом, создается эффект падения дождя под определенным углом к горизонту.

\section{Алгоритмы удаления невидимых линий и поверхностей}
\label{sec:z_buffer}

Сложность задачи удаления невидимых линий и поверхностей привела к появлению большого числа различных способов ее решения. 
Наилучшего решения обшей задачи удаления невидимых линий и поверхностей не существует. 
Учет эффектов прозрачности, фактуры, отражения и т.~п. не входит в задачу удаления невидимых линий или поверхностей. 
Естественнее считать их частью процесса визуализации изображения. 
Однако многие из этих эффектов встроены в алгоритмы удаления невидимых поверхностей. 
Существует тесная взаимосвязь между скоростью работы алгоритма и детальностью его результата. 
Ни один из алгоритмов не может достигнуть хороших оценок для этих двух показателей одновременно. 
По мере создания все более быстрых алгоритмов можно строить все более детальные изображения \cite{Demin2005}.

Алгоритмы удаления невидимых линий или поверхностей можно классифицировать по способу выбора системы координат или пространства, в котором они работают. Выделяют три класса алгоритмов удаления невидимых линий или поверхностей:

\begin{enumerate}
\item[1)]
алгоритмы, работающие в объектном пространстве;
\item[2)]
алгоритмы, работающие в пространстве изображения;
\item[3)]
алгоритмы, формирующие список приоритетов \cite{Demin2005}.
\end{enumerate}

Алгоритмы, работающие в объектном пространстве, имеют дело с физической системой координат, в которой описаны эти объекты. 
При этом получаются весьма точные результаты, ограниченные лишь точностью вычислений. 
Полученные изображения можно свободно увеличивать во много раз. 
Алгоритмы, работающие в объектном пространстве, особенно полезны в тех приложениях, где необходима высокая точность \cite{Demin2005}.

Алгоритмы же, работающие в пространстве изображения, имеют дело с системой координат того экрана, на котором объекты визуализируются. 
При этом точность вычислений ограничена разрешающей способностью экрана. Обычно разрешение экрана бывает довольно низким. 
Результаты, полученные в пространстве изображения, а затем увеличенные во много раз, не будут соответствовать исходной сцене \cite{Demin2005}.

Алгоритмы, формирующие список приоритетов, работают попеременно в обеих упомянутых системах координат \cite{Demin2005}.

В рамках данной курсовой работы разрабатывается программа визуализации дождя в реальном времени, поэтому быстродействие алгоритмов является самым важным фактором. Исходя из этого, нужно выбирать алгоритмы удаления невидимых линий и поверхностей, которые работают в пространстве изображений.

Алгоритм Робертса характеризуется высокой точностью вычислений, но существует ограничение на выпуклость тел и он работает менее эффективно с появлением новых объектов на сцене.

Алгоритм, использующий $Z$-буфер, использует относительно много памяти (так как использует массивы) и с помощью него сложно реализовать эффекты прозрачности. 
Кроме того, недостаток состоит в трудоемкости и высокой стоимости устранения лестничного эффекта. 
Но он обладает простой реализацией, не требует временных затрат на сортировку объектов сцены и скорость работы алгоритма растет линейно при появлении новых объектов.

Алгоритм обратной трассировки лучей позволяет работать с поверхностями, заданными в математической форме, а также позволяет получить высокую реалистичность синтезируемого изображения. 
С другой стороны, алгоритм обладает низкой производительностью.

Таким образом, наилучшим алгоритмом для удаления невидимых линий и поверхностей при визуализации дождя будет алгоритм, использующий $Z$-буфер.

\section{Алгоритм растеризации треугольников}

Так как при визуализации сцены все объекты будут обрабатываться по полигонам (треугольникам), нужен алгоритм растеризации треугольников. 
Этот алгоритм должен обладать следующими свойствами:
\begin{enumerate}
\item[1)] он должен быть простым и быстро работать;
\item[2)] он должен быть симметричным --- картинка не должна зависеть от порядка вершин, переданных в функцию отрисовки;
\item[3)] если два треугольника имеют две общие вершины, между ними не должно быть дырок из-за округлений растеризации.
\end{enumerate}

Алгоритм, который удовлетворяет всем приведенным выше требованиям --- алгоритм заметающей прямой. 
Метод состоит из трех шагов:
\begin{enumerate}
\item[1)] сортировка вершин треугольника по их $y$-координате;
\item[2)] растеризация параллельно левой и правой границ треугольника;
\item[3)] отрисовка горизонтального отрезка между левой и правой точками границы \cite{Souvaine2005}.
\end{enumerate}

\section{Алгоритм построения теней}

Целью текущей куросовой работы является визуализация дождя. Таким образом, есть возможность пренебречь тенями и использовать для визуализации объектов алгоритм, выбранный в пункте~\ref{sec:z_buffer}.

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы были рассмотрены способы представления объектов и алгоритмы, необходимые для построения реалистичных изображений --- алгоритмы, удаляющие невидимые линии и поверхности и алгоритмы построения теней.

В итоге были выбраны:

\begin{enumerate}
\item[1)]
поверхностная модель (путем хранения списка граней) для представления объектов;
\item[2)]
двойной конус для представления дождевых капель;
\item[3)]
алгоритм, использующий $Z$-буфер для удаления невидимых линий и поверхностей.
\end{enumerate}

\chapter{Конструкторская часть}

В данной части описаны все необходимые алгоритмы и средства для визуализации дождя.

\section{Общий алгоритм визуализации сцены}

\begin{enumerate}
\item Установить начальную скорость падения дождя.
\item Установить начальный размер дождевых капель.
\item Установить начальное направление падения дождя.
\item Установить начальную плотность падения дождя.
\item Установить соответствующую цветовую гамму исходя из выбранного времени суток (по умолчанию --- ночь).
\item Установить начальное положение источника света.
\item Установить начальное положение камеры.
\item С учетом текущего положения камеры и источника света визуализировать падение дождя.
\end{enumerate}

\section{Графический конвейер}

Графический конвейер --- комплекс визуализации трехмерной графики, последовательность этапов, выполняющихся в фиксированном порядке. 
Каждое состояние принимает информацию из предыдущего состояния и отправляет в следующее. 
Стандартный графический конвейер обрабатывает вершины, геометрические примитивы, а также пиксели конвейерным способом.

На рисунке~\ref{img:graphics_pipeline} изображена схема графического конвейера, с помощью которого происходит преобразование локальных координат всех объектов в экранные координаты.

\includeimage{graphics_pipeline}
    {f}
    {H}
    {.2\textwidth}
    {Графический конвейер}
    
Все преобразования происходят за счет последовательного умножения следующих матриц: модельной, видовой и проекционной. 
Для составления модельной матрицы нужно умножить матрицы масштабирования, поворота и параллельного переноса \cite{Jeremiah2011}. 

Матрица масштабирования:
\begin{equation}
\begin{gathered}
S = 
	\begin{bmatrix}
		kx & 0 & 0 & 0 \\
		0 & ky & 0 & 0 \\
		0 & 0 & kz & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $kx$, $ky$, $kz$ --- коэффициенты масштабирования \cite{Panov2017}.

Матрица поворота вокруг оси $Ox$:
\begin{equation}
\begin{gathered}
R_x = 
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & \cos{\alpha} & -\sin{\alpha} & 0 \\
		0 & \sin{\alpha} & \cos{\alpha} & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $\alpha$  --- угол поворота вокруг оси $Ox$ \cite{Panov2017}.

Матрица поворота вокруг оси $Oy$:
\begin{equation}
\begin{gathered}
R_y = 
	\begin{bmatrix}
		\cos{\beta} & 0 & \sin{\beta} & 0 \\
		0 & 1 & 0 & 0 \\
		-\sin{\beta} & 0 & \cos{\beta} & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $\beta$  --- угол поворота вокруг оси $Oy$ \cite{Panov2017}.

Матрица поворота вокруг оси $Oz$:
\begin{equation}
\begin{gathered}
R_z = 
	\begin{bmatrix}
		\cos{\gamma} & -\sin{\gamma} & 0 & 0 \\
		\sin{\gamma} & \cos{\gamma} & 0 & 0 \\
		0 & 0 & 1 & 0 \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $\gamma$  --- угол поворота вокруг оси $Oz$ \cite{Panov2017}.

Итоговую матрицу поворота можно получить по следующей формуле:
\begin{equation}
R = R_x \cdot R_y \cdot R_z.
\end{equation}

Матрица параллельного переноса:
\begin{equation}
\begin{gathered}
T = 
	\begin{bmatrix}
		1 & 0 & 0 & dx \\
		0 & 1 & 0 & dy \\
		0 & 0 & 1 & dz \\
		0 & 0 & 0 & 1
	\end{bmatrix},
\end{gathered}
\end{equation}
где $dx$, $dy$, $dz$ --- расстояния, на которые перемещается объект вдоль соответствующих осей \cite{Panov2017}.

Таким образом, модельная матрица может быть посчитана по следующей формуле:
\begin{equation}
M = T \cdot R \cdot S,
\end{equation}
где $T$ --- матрица параллельного переноса, $R$ --- матрица поворота, $S$ --- матрица масштабирования \cite{Jeremiah2011}.

Чтобы составить видовую матрицу, нужны несколько векторов. 
Вектор $From$, который описывает направление <<взгляда>> камеры, вектор $Target$, который указывает куда смотрит камера (этот вектор направлен в обратную сторону относительно вектора $From$), и вектор $Up$ --- вектор, направленный вверх. 
Вектор $Forward$ можно найти как разность векторов $From$ и $Target$. 
Вектор $Right$ можно найти как векторное произведение векторов $Up$ и $Forward$. 
Вектор $U$ можно найти как векторное произведение векторов $Forward$ и $Right$ \cite{Jeremiah2011}.

Видовая матрица:
\begin{equation}
\begin{gathered}
V = 
	\begin{bmatrix}
		Right_x & Right_y & Right_z & 0 \\
		U_x & U_y & U_z & 0 \\
		Forward_x & Forward_y & Forward_z & 0 \\
		From_x & From_y & From_z & 1
	\end{bmatrix}.
\end{gathered}
\end{equation}

Пусть $z_{near}$ --- положение ближней к камере плоскости, а $z_{far}$ --- дальней.

Матрица проекции \cite{Jeremiah2011}:
\begin{equation}
\begin{gathered}
P = 
	\begin{bmatrix}
		\frac{\fov}{\aspect} & 0 & 0 & 0 \\
		0 & \fov & 0 & 0 \\
		0 & 0 & -f & 0 \\
		0 & 0 & 0 & f \cdot z_{near}
	\end{bmatrix},
\end{gathered}
\end{equation}
где $\fov$ --- угол обзора в радианах, $\aspect$ --- отношение ширины сцены к высоте, а $f$ --- величина, которую можно посчитать по формуле:
\begin{equation}
f = \frac{-z_{far}}{(z_{far} - z_{near})}.
\end{equation}

Таким образом, полная матрица, которая описывает все преобразования, может быть посчитана по формуле \cite{Jeremiah2011}:
\begin{equation}
\mvp = P \cdot V \cdot M,
\end{equation}
где $P$ --- проекционная матрица, $V$ --- видовая матрица, $M$ --- модельная матрица.

Чтобы получить преобразованные координаты, нужно исходный вектор $V$ умножить на матрицу $\mvp$ \cite{Jeremiah2011}:
\begin{equation}
V' = \mvp \cdot V.
\end{equation}
    
\section{Описание геометрии}
\label{sec:geometry}

В рамках выполнения курсовой работы для хранения данных об объектах был выбран формат файлов \textbf{OBJ} --- это простой формат данных, который содержит только трехмерную геометрию, а именно: позицию каждой вершины, связь координат текстуры с вершиной, нормаль для каждой вершины, а также параметры, которые создают полигоны. 
В качестве полигонов будут использоваться треугольники.

Для считывания объектов из \textbf{OBJ} файла используются строки, начинающиеся на \textbf{v} и \textbf{f}. 
Числа, расположенные после \textbf{v}, являются координатами текущей вершины, а числа, расположенные после \textbf{f}, показывают, из каких вершин состоит текущая грань.

\section{Описание алгоритмов}

\subsection*{Алгоритм, использующий $Z$-буфер}
\addcontentsline{toc}{subsection}{Алгоритм, использующий $Z$-буфер}

На рисунке~\ref{img:z_buffer} показана схема алгоритма, использующего $Z$-буфер.

\includeimage{z_buffer}
    {f}
    {H}
    {.7\textwidth}
    {Схема алгоритма, использующего $Z$-буфер}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы был описан общий алгоритм визуализации сцены, графический конвейер и геометрия. 
Также на основе теоретических данных, полученных из аналитического раздела, была построена схема алгоритма, использующего $Z$-буфер.

\chapter{Технологическая часть}

В текущем разделе приведены средства реализации необходимых структур данных и алгоритмов, а также листинги кода.

\section{Требования к программному обеспечению}

Программа должна предоставлять следующие функции.
\begin{enumerate}
\item
Смена времени суток --- дня и ночи.
\item
Поворот камеры вокруг осей $Ox$ и $Oy$.
\item
Изменение скорости падения дождя.
\item
Изменение размера капель дождя.
\item
Изменение плотности падения дождя.
\item
Изменение направления падения дождя.
\item
Изменение положения источника света вдоль осей $Ox$ и $Oy$.
\end{enumerate}

\section{Средства реализации}

Для реализации программного обеспечения был выбран язык программирования \textbf{C\texttt{++}} и фреймворк \textbf{Qt} для разработки кроссплатформенного программного обеспечения на языке программирования \textbf{C\texttt{++}} ввиду следующих причин:
\begin{enumerate}
\item[1)] в стандартной библиотеке шаблонов языка \textbf{C\texttt{++}} реализованы структуры данных, которые удобно использовать для хранения вершин и граней объектов;
\item[2)] фреймворк \textbf{Qt} дает возможность создавать различные виджеты для реализации графического пользовательского интерфейса, в том числе, классы \textbf{QGraphicsView} и \textbf{QImage}, которые можно использовать в качестве сцены для визуализации объектов;
\item[3)] фреймворк \textbf{Qt} предоставляет доступ к классу \textbf{QTimer}, который можно использовать для анимации дождя.
\end{enumerate}

Таким образом, с помощью языка \textbf{C\texttt{++}} и фреймворка \textbf{Qt} можно реализовать программное обеспечение, которое соответствует перечисленным выше требованиям.

Для создания моделей было выбрано программное обеспечение для создания трехмерной компьютерной графики под названием \textbf{Blender}, которое позволяет создавать трехмерные модели, состоящие из треугольных полигонов, что подходит под требования, описанные в пункте~\ref{sec:geometry}.

\section{Модель дождевой капли}

На рисунке~\ref{img:droplet} показана модель дождевой капли, сделанная в программе \textbf{Blender}.

\includeimage{droplet}
    {f}
    {H}
    {.5\textwidth}
    {Модель дождевой капли}

\pagebreak
\section{Реализация структур данных}

\subsection{Вершины}

В листинге~\ref{lst:vertex.cpp} показана реализация класса, который отвечает за хранение координат одной вершины объекта.

\includelistingpretty
{vertex.cpp}{c++}{Класс вершин}

\pagebreak
\subsection{Грани}

В листинге~\ref{lst:face.cpp} показана реализация класса, который отвечает за хранение одной грани объекта. 
В массиве \textbf{vertices} хранится три порядковых номера вершин, которые образуют один полигон (треугольник).

\includelistingpretty
{face.cpp}{c++}{Класс граней}

\subsection{Объекты}

В листинге~\ref{lst:object.cpp} показана реализация базового класса, который представляет собой объект сцены. 
Классы других объектов можно создавать на основе класса \textbf{Object}. 
Класс хранит текущее смещение объекта, коэффициенты масштабирования и углы поворотов вокруг трех осей. 
Кроме того, для \textbf{Object} реализованы методы для преобразований объекта и визуализации (метод \textbf{draw()}).

\includelistingpretty
{object.cpp}{c++}{Класс объектов}

\section{Реализация алгоритмов}

\subsection{Алгоритм, использующий $Z$-буфер}

В листинге~\ref{lst:draw_polygon.cpp} показана реализация метода \textbf{draw\_polygon()} для класса \textbf{Object}, который представляет собой реализацию алгоритма, использующего $Z$-буфер. 
Метод в качестве параметров принимает три вершины полигона, массив, представляющий собой $Z$-буфер, указатель на сцену и цвет полигона. 
Чтобы визуализировать весь объект, нужно вызвать метод \textbf{draw\_polygon()} для всех полигонов.

\includelistingpretty
{draw_polygon.cpp}{c++}{Алгоритм, использующий $Z$-буфер}

\subsection{Алгоритм генерации дождевых капель}

В листинге~\ref{lst:generate_rain.cpp} показана реализация метода \textbf{generateRain()}, который отвечает за первоначальное размещение на сцене всех капель дождя.

\includelistingpretty
{generate_rain.cpp}{c++}{Алгоритм генерации дождевых капель}

\pagebreak
\subsection{Алгоритм анимации дождя}

В листинге~\ref{lst:animation.cpp} показана реализация метода \textbf{animate()}, который отвечает за анимацию дождя.

\includelistingpretty
{animation.cpp}{c++}{Алгоритм анимации дождя}

\section*{Вывод из технологической части}

В данном разделе был написан исходный код необходимых структур данных и алгоритмов визуализации сцены и анимации объектов. 

\chapter{Исследовательская часть}

\section*{Примеры работы программы}
\addcontentsline{toc}{section}{Примеры работы программы}

На рисунках~\ref{img:work_example_01}--\ref{img:work_example_05} показаны примеры работы программы при различных параметрах дождя и сцены.

\includeimage{work_example_01}
    {f}
    {H}
    {0.9\textwidth}
    {Дождь в ночное время суток}
    
\includeimage{work_example_02}
    {f}
    {H}
    {0.9\textwidth}
    {Дождь в дневное время суток}
    
\includeimage{work_example_03}
    {f}
    {H}
    {0.9\textwidth}
    {Измененное положение камеры}
    
\includeimage{work_example_04}
    {f}
    {H}
    {0.9\textwidth}
    {Максимальный размер капель дождя}
    
\includeimage{work_example_05}
    {f}
    {H}
    {0.9\textwidth}
    {Измененное положение источника света}

\section*{Вывод из исследовательской части}

В данном разделе представлены примеры работы программы при различных параметрах дождя и сцены. 

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы было реализовано программное обеспечение для визуализации дождя в реальном времени с возможностью изменения с помощью графического интерфейса таких характеристик, как размер капель, скорость падения дождя, направление падения дождевых капель и плотность дождя. 
Также была реализована возможность изменения положения источника света вдоль осей $Ox$ и $Oy$, поворот камеры вокруг осей $Ox$ и $Oy$ и смена дня и ночи.

Были выполнены следующие задачи:
\begin{enumerate}
\item[1)]
выбран способ представления объектов на сцене;
\item[2)]
выбрана модель дождевых капель;
\item[3)]
проанализированы алгоритмы удаления невидимых линий и поверхностей и выбран наиболее подходящий;
\item[4)]
проанализированы алгоритмы создания реалистичного освещения, отражений и теней и выбран наиболее подходящий;
\item[5)]
проанализированы и выбраны средства программной реализации;
\item[6)]
реализованы выбранные алгоритмы для создания программы визуализации дождя в реальном времени;
\item[7)]
создан графический интерфейс для возможности изменения характеристик дождя и сцены пользователем.
\end{enumerate}

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ]}
\addcontentsline{toc}{chapter}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Презентация}
\center{(Обязательное)}
\center{\textbf{Презентация}}

\end{document}
